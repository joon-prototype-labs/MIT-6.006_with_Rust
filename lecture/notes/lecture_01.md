## 리뷰

강의 내용은 pdf 노트에 잘 요약되어 있음.

[MIT 사이트](https://ocw.mit.edu/courses/6-006-introduction-to-algorithms-fall-2011/pages/syllabus/)서 평가 기준을 보는데, 인상깊은 문장을 몇가지 가져옴.
- 가장 좋은 답변은 간결하고, 정확하고, 완전한 것입니다.
- 무엇보다도 당신의 목표는 소통이라는 것을 기억하세요. 결국, 채점자가 당신의 해결책을 이해하지 못한다면, 그들은 당신에게 그것에 대한 어떤 공로도 줄 수 없습니다.


### 극댓값 찾기 이해하기

#### Claude의 설명

강의 내용에 따르면 극댓값(peak)은 다음과 같이 정의됩니다:

1차원 배열의 경우:
- 위치 2의 값 b가 극댓값이 되려면:
   - b ≥ a (왼쪽 값보다 크거나 같음)
   - b ≥ c (오른쪽 값보다 크거나 같음)
   - 즉, c ≥ b ≥ a 를 만족해야 함. 
- 끝점(예: 9번 위치)의 경우:
   - i ≥ h (마지막 위치라면 왼쪽 값보다만 크거나 같으면 됨)

2차원 배열의 경우:
- 중앙값 a가 극댓값이 되려면:
   - a ≥ b (위쪽 값보다 크거나 같음)
   - a ≥ d (왼쪽 값보다 크거나 같음)
   - a ≥ c (아래쪽 값보다 크거나 같음)
   - a ≥ e (오른쪽 값보다 크거나 같음)

즉, 극댓값은 자신의 인접한 모든 값들보다 크거나 같은 값을 의미합니다. 1차원에서는 좌우 값만 비교하고, 2차원에서는 상하좌우 값을 모두 비교합니다.

중요한 점은 "크거나 같다(≥)"를 사용하기 때문에 모든 배열에는 반드시 극댓값이 존재한다는 것입니다. 만약 "크다(>)"를 사용했다면 극댓값이 존재하지 않는 경우도 있을 수 있습니다.

#### 궁금한 점 Claude한테 질문 및 정리

1. 극댓값의 정의
- 1차원에서: 자신의 좌우 값보다 크거나 같은 값
- 2차원에서: 자신의 상하좌우 값보다 크거나 같은 값
- 중요: "크거나 같다(≥)"를 사용하므로 모든 배열에는 극댓값이 존재함

2. 핵심 특징
- 전역 최댓값(가장 큰 값)이 아닌 지역 최댓값
- 정렬된 상태일 필요가 없음
- 하나의 배열에 여러 개의 극댓값이 존재할 수 있음

3. 효율적인 찾기 방법 (분할 정복)
```python
예시 배열: [3, 6, 8, 5, 4, 7, 9, 2]
```
a) 중간값 확인
- 중간값과 그 양옆 값을 비교
- 더 큰 값이 있는 방향으로 이동

b) 왜 효율적인가?
- 매번 탐색 범위가 절반으로 줄어듦
- 큰 쪽으로 가면 반드시 극댓값이 존재
- 모든 값을 볼 필요가 없음

4. 흔한 오해 해소
- "정렬되어 있어야 하는 것 아닌가요?"
  → 아니요, 지역적 비교만 하므로 정렬 불필요
- "모든 값을 봐야 하는 것 아닌가요?"
  → 아니요, 큰 쪽으로만 가면 되므로 O(log n) 가능
- "작은 쪽으로 가도 되나요?"
  → 안됩니다. 극댓값을 놓칠 수 있음

5. 시간 복잡도
- 단순 검색: O(n) - 모든 원소 확인
- 분할 정복: O(log n) - 매번 절반으로 줄임

6. 예시로 보는 동작 과정
```
[3, 6, 8, 5, 4, 7, 9, 2]
1단계: 중간값 4 확인
       왼쪽 5 > 4이므로 왼쪽으로 이동
2단계: [3, 6, 8, 5] 에서 중간값 8 확인
       8은 양옆(6, 5)보다 크므로 극댓값!
```

이런 식으로 큰 쪽으로만 이동하면서 효율적으로 극댓값을 찾을 수 있습니다. 정렬 여부와 관계없이 지역적 비교만으로 극댓값을 찾을 수 있다는 점이 이 알고리즘의 핵심입니다.

#### 알고리즘 맞는지 증명하기?
- 이게 과제일지는 몰랐는데...
- 귀납법으로 증명해야하나?

##### Claude 설명

극댓값 찾기 알고리즘의 정확성을 수학적으로 증명하기 위해서는 다음과 같은 방법을 사용할 수 있습니다:

1. **귀납법 사용**

기본 가정:
- 배열 A[1...n]이 주어짐
- 모든 인접한 요소들은 서로 비교 가능

귀납법 증명:

**기본 단계 (Base Case)**:
- n = 1일 때: 한 개의 원소만 있으므로 그 원소가 자동으로 극댓값
- n = 2일 때: 두 원소를 비교하여 더 큰 값(또는 같은 값)이 극댓값

**귀납 단계 (Inductive Step)**:
- n > 2인 경우에 대해 귀납법 적용
- 귀납 가정: n/2 크기의 배열에서 알고리즘이 올바르게 작동한다고 가정

2. **정당성 증명**

```
중간 지점 m = ⌊n/2⌋에서:

Case 1: A[m] ≥ A[m-1] 이고 A[m] ≥ A[m+1]
        → A[m]이 극댓값

Case 2: A[m] < A[m-1]
        → 왼쪽 부분에 극댓값 존재 증명:
        - A[m-1] > A[m]이므로
        - 왼쪽으로 가면서 계속 증가하거나
        - 어느 지점에서 감소하면 그 직전 값이 극댓값
        
Case 3: A[m] < A[m+1]
        → 오른쪽 부분에 극댓값 존재 증명:
        - A[m+1] > A[m]이므로
        - 오른쪽으로 가면서 계속 증가하거나
        - 어느 지점에서 감소하면 그 직전 값이 극댓값
```

3. **불변식(Invariant) 증명**

루프 불변식:
- 매 반복마다 탐색 구간에는 적어도 하나의 극댓값이 존재

4. **종료 증명**

알고리즘이 항상 종료됨을 보이기 위해:
- 매 단계마다 문제의 크기가 절반으로 감소
- log n 단계 후에는 반드시 종료

5. **정확성 증명 요약**

```
정리: 이 알고리즘은 항상 극댓값을 찾는다.

증명:
1) 알고리즘은 항상 종료된다 (크기가 절반씩 감소)
2) 불변식이 유지된다 (탐색 구간에 극댓값 존재)
3) 종료 시점에서 찾은 값은 극댓값의 정의를 만족한다
∴ 알고리즘은 정확하다
```

이러한 수학적 증명을 통해 알고리즘이:
1. 항상 종료되고
2. 올바른 결과를 반환하며
3. 주어진 시간 복잡도 내에서 동작함을 보일 수 있습니다.

##### 분석

보고 알 수 있는건, 항상 종료되고, 올바른 결과를 반환하며, 주어진 시간 복잡도내에서 동작하는 것을 증명해야 함.

위 경우 재귀적으로 수행하다가 n=1이 되면 종료되고, 모든 경우를 고려한다(MECE).     
수행하는 행위의 횟수를 계산했을 떄 log2N과 근사하다.

근데 이걸 내가 수학적으로 풀어내기에는 고졸따리라 힘들고, 분석해서 예측해보고 AI 도움을 받아서 정리하지 않을까 싶음.

#### 2차원의 경우
```
T(n,m) = T(n,m/2) + θ(n)

여기서:
- n: 행의 수(세로 길이)
- m: 열의 수(가로 길이)
- θ(n): 한 열에서 최댓값을 찾는 비용
```

근데 여기서
열 하나의 최댓값 찾는 비용이 n이므로 선형 시간이고, T의 경우 재귀적으로 문제를 절반씩 줄이므로 log2N으로 로그 시간임.

결론적으로 O(NlogN)임.

Claude도 맞다고 함.

```
100 x 100 행렬의 경우:
- log₂100 ≈ 7 (열 분할 횟수)
- 각 단계마다 100개 원소 비교
- 총 연산: 약 700번

단순 검색(O(nm))의 경우:
- 10,000번의 비교 필요
```

